
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#include "legup/types.h"
#include "legup/streaming.h"


#define LEGUP_FLT2INT(a) (*(unsigned*)&(a))
#define LEGUP_DBL2INT(a) (*(unsigned long long*)&(a))
#define LEGUP_INT2FLT(a) (*(float*)&(a))
#define LEGUP_INT2DBL(a) (*(double*)&(a))

// Generated by this C program: *.sw.dat
// Generated from hardware simulation: *.hw.dat
const char* return_val_OUT_SW_DAT = "simulation/sw/main_return_val.out.sw.dat";
const char* return_val_OUT_HW_DAT = "simulation/sw/main_return_val.out.hw.dat";


// store the number of calls when the program ends in tb_config.tcl
// Note: deconstructor will only work in GCC
int num_calls = 0;
void __attribute__ ((destructor)) dtor() {
    if (num_calls > 0) {
        FILE *tb_config_tcl = fopen("simulation/sw/tb_config.tcl", "w");
        assert(tb_config_tcl);
        fprintf(tb_config_tcl, "set_parameter COSIM_TB_NUM_CALLS %d\n", num_calls);
    }
}





// original top-level prototype
int  main();

// instrumentation wrapper around original top-level
int  main_LEGUP_WRAP() {
    int i;
    static FILE *verify_hw = NULL;
    if (!verify_hw)
        verify_hw = fopen(".verify_hw", "r");

    static FILE *return_val_out_sw_file = NULL;
static FILE *return_val_out_hw_file = NULL;


    

    if (verify_hw) {
        
        // running after hardware simulation.
        // Don't call the original software function, instead use the hardware
        // simulation results as the output
        
        
        if (!return_val_out_hw_file) {
            return_val_out_hw_file = fopen(return_val_OUT_HW_DAT, "r");
            if (!return_val_out_hw_file) {
                printf("Error: Unable to open '%s'\n", return_val_OUT_HW_DAT);
                exit(1);
            }
        }
    

        // discard inputs
        

        // read output vectors from hardware simulation
        
            int return_val_writes = 0;
            int return_val_call = 0;
            assert(fscanf(return_val_out_hw_file, "Call %d: %d transfers\n", &return_val_call, &return_val_writes));
            int32 return_val;
            
                    assert(fscanf(return_val_out_hw_file, "%x\n", &return_val));
                
            int  return_val_out = (return_val);
            return return_val_out;
            
        
        printf("Retrieving hardware outputs from RTL simulation for main function call %d.\n", ++num_calls);

    } else {
        
        printf("Gathering inputs/outputs from software execution for main function call %d.\n", num_calls+1);
        // generate input test vectors for simulation

        
        if (!return_val_out_sw_file) {
            return_val_out_sw_file = fopen(return_val_OUT_SW_DAT, "w");
            if (!return_val_out_sw_file) {
                printf("Error: Unable to open '%s'\n", return_val_OUT_SW_DAT);
                exit(1);
            }
        }
    

        

        

        

        // dump the input to the .dat file
        

        
        // call original top level function
        int  return_val = main();
        

        

        // dump the fifo input to the .dat file
        

        // dump the expected output to the .dat file
        
            fprintf(return_val_out_sw_file, "Call %d: %d transfers\n", num_calls, 1);
            fprintf(return_val_out_sw_file, "%x\n", (return_val));
            
        
        // free cloned fifos
        

        num_calls++;

        return return_val;
    }
}
